// Generated by CoffeeScript 1.4.0

/*
#   licensed under apache commons license
#   created by: Igor Sarcevic
#   @mail : igisar@gmail.com
#   @github : shiroyahsa
*/


(function() {
  var DEBUG, Game, GameRules, MODES, POSITIONS, TicTacToeGame, TicTacToeRules, TicTacToeView, ispis,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DEBUG = false;

  ispis = function(depth, v, action) {
    var i, prefix, _i;
    if (!DEBUG) {
      return;
    }
    prefix = "";
    for (i = _i = 0; 0 <= depth ? _i <= depth : _i >= depth; i = 0 <= depth ? ++_i : --_i) {
      prefix += '----';
    }
    return console.log(prefix, 'action ', action, '= ', v, depth % 2 === 0 ? "max" : "min");
  };

  GameRules = (function() {

    function GameRules() {}

    GameRules.prototype.possibleMoves = function(state) {
      return [];
    };

    GameRules.prototype.makeMove = function(state) {
      return null;
    };

    GameRules.prototype.terminalTest = function(state) {
      return false;
    };

    return GameRules;

  })();

  Game = (function() {

    Game.prototype.setDebug = function(d) {
      return DEBUG = d;
    };

    /*
            rules is an object that contains three functions
            that define the game logic
            - possibleMoves - generates all the moves from the given state
            - makeMove - generates resulting move from the state
            - terminalTest - tests if the game state is terminal
    */


    function Game(rules) {
      this.rules = rules;
    }

    /*
            generates the move using minimax algorithm
            - state is an object that contains information about game state 
            - maxDepth is the maximal depth the algorithm will go
            - heuristic - function that evaluates the given state as an integer
    
            TODO: make it more 'functional like'
    */


    Game.prototype.generateMove = function(state, heuristic, maxDepth) {
      var a, action, alpha, beta, result, value, _i, _len, _ref;
      this.heuristic = heuristic;
      this.maxDepth = maxDepth;
      if (this.rules.terminalTest(state) || this.maxDepth === 0) {
        return null;
      }
      value = Number.NEGATIVE_INFINITY;
      action = null;
      alpha = Number.NEGATIVE_INFINITY;
      beta = Number.POSITIVE_INFINITY;
      _ref = this.rules.possibleMoves(state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        result = this._minMinimax(this.rules.makeMove(state, a), 1, alpha, beta);
        ispis(0, result, a);
        if (result > value) {
          value = result;
          action = a;
        }
        alpha = Math.max(result, alpha);
      }
      return action;
    };

    Game.prototype._maxMinimax = function(state, depth, alpha, beta) {
      var a, result, value, _i, _len, _ref;
      if (this.rules.terminalTest(state) || this.maxDepth === depth) {
        return this.heuristic(state);
      }
      value = Number.NEGATIVE_INFINITY;
      _ref = this.rules.possibleMoves(state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        result = this._minMinimax(this.rules.makeMove(state, a), depth + 1, alpha, beta);
        ispis(depth, result, a);
        value = Math.max(value, result);
        if (value >= beta) {
          return value;
        }
        alpha = Math.max(result, alpha);
      }
      return value;
    };

    Game.prototype._minMinimax = function(state, depth, alpha, beta) {
      var a, result, value, _i, _len, _ref;
      if (this.rules.terminalTest(state) || this.maxDepth === depth) {
        return this.heuristic(state);
      }
      value = Number.POSITIVE_INFINITY;
      _ref = this.rules.possibleMoves(state);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        result = this._maxMinimax(this.rules.makeMove(state, a), depth + 1, alpha, beta);
        ispis(depth, result, a);
        value = Math.min(value, result);
        if (value <= alpha) {
          return value;
        }
        beta = Math.min(result, beta);
      }
      return value;
    };

    return Game;

  })();

  /*
      state is an object that contains the board and player
       - board : array of length nine
          - 0 : x
          - 1 : y
          - 2 : nothing
       - player
          - 0 : x
          - 1 : y
  */


  TicTacToeRules = (function(_super) {

    __extends(TicTacToeRules, _super);

    function TicTacToeRules() {
      return TicTacToeRules.__super__.constructor.apply(this, arguments);
    }

    TicTacToeRules.prototype.possibleMoves = function(state) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = state.board.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (state.board[i] === 2) {
          _results.push(i);
        }
      }
      return _results;
    };

    TicTacToeRules.prototype.makeMove = function(state, action) {
      var b;
      b = state.board.slice(0);
      b[action] = state.player;
      return {
        board: b,
        player: state.player === 0 ? 1 : 0
      };
    };

    TicTacToeRules.prototype.wonGameTest = function(state) {
      var check, i, niz1, niz2, _i, _j, _ref, _ref1;
      check = function(i, j, k, player) {
        return state.board[i] === player && state.board[j] === player && state.board[k] === player;
      };
      niz1 = [check(0, 1, 2, 0), check(3, 4, 5, 0), check(6, 7, 8, 0), check(0, 3, 6, 0), check(1, 4, 7, 0), check(2, 5, 8, 0), check(0, 4, 8, 0), check(2, 4, 6, 0)];
      niz2 = [check(0, 1, 2, 1), check(3, 4, 5, 1), check(6, 7, 8, 1), check(0, 3, 6, 1), check(1, 4, 7, 1), check(2, 5, 8, 1), check(0, 4, 8, 1), check(2, 4, 6, 1)];
      for (i = _i = 0, _ref = niz1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (niz1[i]) {
          return {
            winer: 0,
            index: i
          };
        }
      }
      for (i = _j = 0, _ref1 = niz2.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (niz2[i]) {
          return {
            winer: 1,
            index: i
          };
        }
      }
      return null;
    };

    TicTacToeRules.prototype.tieTest = function(state) {
      var b, _i, _len, _ref;
      _ref = state.board;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        if (b === 2) {
          return false;
        }
      }
      return true;
    };

    TicTacToeRules.prototype.terminalTest = function(state) {
      return (this.wonGameTest(state) != null) || this.tieTest(state);
    };

    return TicTacToeRules;

  })(GameRules);

  TicTacToeGame = (function(_super) {

    __extends(TicTacToeGame, _super);

    function TicTacToeGame(player) {
      this.setPlayer(player);
      TicTacToeGame.__super__.constructor.call(this, new TicTacToeRules());
      this.ddd = false;
    }

    TicTacToeGame.prototype.play = function(state) {
      return this.generateMove(state, this.heuristic);
    };

    TicTacToeGame.prototype.setPlayer = function(player) {
      this.player = player;
      return this.opponent = this.player === 0 ? 1 : 0;
    };

    TicTacToeGame.prototype.setddd = function(ddd) {
      this.ddd = ddd;
    };

    TicTacToeGame.prototype.heuristic = function(state) {
      var LOSE, WIN, calculate, i, niz, o, p, rez, _i, _j, _len, _len1;
      WIN = 5000;
      LOSE = -5000;
      calculate = function(i, j, k) {
        var rez;
        rez = [0, 0, 0];
        rez[state.board[i]] = rez[state.board[i]] + 1;
        rez[state.board[j]] = rez[state.board[j]] + 1;
        rez[state.board[k]] = rez[state.board[k]] + 1;
        return [rez[0], rez[1]];
      };
      niz = [calculate(0, 1, 2), calculate(3, 4, 5), calculate(6, 7, 8), calculate(0, 3, 6), calculate(1, 4, 7), calculate(2, 5, 8), calculate(0, 4, 8), calculate(2, 4, 6)];
      if (this.ddd) {
        console.log(niz);
      }
      rez = 0;
      for (_i = 0, _len = niz.length; _i < _len; _i++) {
        i = niz[_i];
        p = i[this.player];
        o = i[this.opponent];
        if (p === 3) {
          return WIN;
        }
        if (o === 3) {
          return LOSE;
        }
      }
      for (_j = 0, _len1 = niz.length; _j < _len1; _j++) {
        i = niz[_j];
        p = i[this.player];
        o = i[this.opponent];
        if (p === 2 && o === 0 && state.player === this.player) {
          return WIN;
        }
        if (p === 0 && o === 2 && state.player === this.opponent) {
          return LOSE;
        }
        if (p === 2 && o === 0 && state.player === this.opponent) {
          return 1000;
        }
        if (p === 0 && o === 2 && state.player === this.player) {
          return -1000;
        }
      }
      return rez;
    };

    return TicTacToeGame;

  })(Game);

  window.game = new TicTacToeGame(0);

  POSITIONS = [[0, 0], [200, 0], [400, 0], [0, 200], [200, 200], [395, 200], [0, 400], [200, 390], [390, 390]];

  MODES = {
    player_vs_comp: 0,
    comp_vs_player: 1,
    comp_vs_comp: 2
  };

  TicTacToeView = (function() {

    function TicTacToeView(id, images) {
      var _this = this;
      this.id = id;
      this.images = images;
      this.ctx = document.getElementById(this.id).getContext('2d');
      $('#' + this.id).click(function(ev) {
        return _this.onClick(ev);
      });
      this.gameInProcess = false;
      this.moveTimer = null;
    }

    TicTacToeView.prototype.restart = function(mode) {
      var field;
      this.mode = mode;
      this.gameInProcess = true;
      clearTimeout(this.moveTimer);
      this.ctx.clearRect(0, 0, 550, 550);
      this.state = {
        board: [2, 2, 2, 2, 2, 2, 2, 2, 2],
        player: 0
      };
      if (this.mode === MODES.comp_vs_player || this.mode === MODES.comp_vs_comp) {
        game.setPlayer(0);
        field = game.play(this.state);
        return this.makeMove(field);
      } else {
        return game.setPlayer(1);
      }
    };

    TicTacToeView.prototype.makeMove = function(field) {
      var callback, info,
        _this = this;
      if (!this.gameInProcess) {
        return;
      }
      if (this.state.board[field] !== 2) {
        return;
      }
      this.state.board[field] = this.state.player;
      this.draw(this.state.player, field);
      this.state.player = this.state.player === 0 ? 1 : 0;
      if (this.mode === MODES.comp_vs_comp) {
        game.setPlayer(this.state.player);
      }
      if (game.rules.terminalTest(this.state)) {
        this.gameInProcess = false;
        info = game.rules.wonGameTest(this.state);
        if (info != null) {
          this.drawLine(info.index);
        }
        return;
      }
      if ((this.mode === MODES.comp_vs_comp) || (this.mode === MODES.player_vs_comp && this.state.player === 1) || (this.mode === MODES.comp_vs_player && this.state.player === 0)) {
        callback = function() {
          return _this.makeMove(game.play(_this.state));
        };
        return this.moveTimer = setTimeout(callback, 1000);
      }
    };

    TicTacToeView.prototype.draw = function(player, field) {
      var img, x, y;
      img = player === 0 ? this.images.x : this.images.o;
      x = POSITIONS[field][0];
      y = POSITIONS[field][1];
      return this.ctx.drawImage(img, 0, 0, 150, 150, x, y, 150, 150);
    };

    TicTacToeView.prototype.drawLine = function(index) {
      var x, y;
      console.log(index);
      if (index === 0 || index === 1 || index === 2) {
        y = POSITIONS[index * 3][1] + 60;
        return this.ctx.drawImage(this.images.horizontal, 0, 0, 550, 50, 0, y, 550, 50);
      } else if (index === 3 || index === 4 || index === 5) {
        x = POSITIONS[index - 3][0] + 60;
        return this.ctx.drawImage(this.images.vertical, 0, 0, 50, 550, x, 0, 50, 550);
      } else if (index === 6) {
        return this.ctx.drawImage(this.images.main_diagonal, 0, 0, 550, 550, 0, 0, 550, 550);
      } else if (index === 7) {
        return this.ctx.drawImage(this.images.minor_diagonal, 0, 0, 550, 550, 0, 0, 550, 550);
      }
    };

    TicTacToeView.prototype.onClick = function(ev) {
      var i, x, y, _i, _ref;
      if (this.mode === MODES.player_vs_comp && this.state.player === 1) {
        return;
      }
      if (this.mode === MODES.comp_vs_comp) {
        return;
      }
      if (this.mode === MODES.comp_vs_player && this.state.player === 0) {
        return;
      }
      x = ev.pageX - $('#' + this.id).offset().left;
      y = ev.pageY - $('#' + this.id).offset().top;
      for (i = _i = 0, _ref = POSITIONS.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((POSITIONS[i][0] <= x && x <= POSITIONS[i][0] + 150) && (POSITIONS[i][1] <= y && y <= POSITIONS[i][1] + 150)) {
          this.makeMove(i);
          return;
        }
      }
    };

    return TicTacToeView;

  })();

  window.startGame = function() {
    var to_load;
    to_load = ['img/x.png', 'img/o.png', 'img/horizontal.png', 'img/vertical.png', 'img/main_diagonal.png', 'img/minor_diagonal.png'];
    return imgpreload(to_load, function(images) {
      var rez, view;
      rez = {
        x: images[0],
        o: images[1],
        horizontal: images[2],
        vertical: images[3],
        main_diagonal: images[4],
        minor_diagonal: images[5]
      };
      view = new TicTacToeView('gameField', rez);
      view.restart(MODES.comp_vs_player);
      $('#restartPlayerCompBtn').click(function() {
        return view.restart(MODES.player_vs_comp);
      });
      $('#restartCompPlayerBtn').click(function() {
        return view.restart(MODES.comp_vs_player);
      });
      return $('#restartCompCompBtn').click(function() {
        return view.restart(MODES.comp_vs_comp);
      });
    });
  };

}).call(this);
